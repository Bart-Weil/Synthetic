// class that generates acronyms by the following algorithm:
// Generate word by calling generateWord()
// Corpus is a file in the same directory as the program called "corpus.txt" 
// with words separated by newlines word is 
// generated by breaking corpus of words into n-letter chunks.
// Lists of starting chunks and ending chunks are created.
// The start of the word is made by selecting a start chunk.
// the next chunk(s) are selected by matching the last n-1 characters
// of the previous n-chunk with the first n-1 characters of the next n-chunk.
// If no match is found, a new start chunk is selected. This process is repeated
// until the word is of the desired length - 1. A matching end chunk is then selected.
// If the process fails to find a matching end chunk, a new start chunk is selected.

#include <set>
#include <string>
#include <random>
#include <iostream>
#include <fstream> 

#include "Word_Generator/WordGenerator.h"

std::string WordGenerator::generateWord(int length) {
  if (length < tileSize) {
    return "";
  }
  std::string word = "";
  while (word == "") {
    word = tryGenerateWord(length);
  }
  return word;
}

WordGenerator::WordGenerator(int tileSize, std::string corpusFile) {
  this->tileSize = tileSize;
  // read in corpus file to populate startChunks, endChunks, and chunks
  std::ifstream corpus(corpusFile);
  std::string line;
  while (getline(corpus, line)) {
    int lineLength = static_cast<int>(line.length());
    if (lineLength >= tileSize) {
      startChunks.insert(line.substr(0, tileSize));
      endChunks.insert(line.substr(line.length() - tileSize, tileSize));   
      if (lineLength > tileSize) {
        for (int pos = 1; pos < lineLength - tileSize - 1; ++pos) {
          chunks.insert(line.substr(pos, tileSize));
        }
      }
    }
  }
}

std::string WordGenerator::tryGenerateWord(int length) {
  std::random_device rd;
  std::mt19937 gen(rd());
  std::uniform_int_distribution<> startDist(0, static_cast<int>(startChunks.size() - 1));
  std::uniform_int_distribution<> chunkDist(0, static_cast<int>(chunks.size() - 1));
  std::uniform_int_distribution<> endDist(0, static_cast<int>(endChunks.size() - 1));

  std::string word = "";
  std::string startChunk = *next(startChunks.begin(), startDist(gen));
  word += startChunk;

  if (length == tileSize) {
    return word;
  }

  std::string *validChunks = new std::string[startChunks.size()];

  for (int i = 0; i < length - 1 - tileSize; ++i) {
    std::string nextChunk = "";
    int numValidChunks = 0;
    
    for (auto it = chunks.begin(); it != chunks.end(); ++it) {
      if (startChunk.substr(1, tileSize - 1) == it->substr(0, tileSize - 1)) {
        validChunks[numValidChunks++] = *it;
      }
    }

    std::uniform_int_distribution<> validDist(0, numValidChunks - 1);

    if (numValidChunks > 0) {
      nextChunk = validChunks[validDist(gen)];
    }

    if (nextChunk == "") {
      return "";
    } else {
      word += nextChunk[tileSize - 1];
      startChunk = nextChunk;
    }
  }
  std::string endChunk = "";
  for (auto it = endChunks.begin(); it != endChunks.end(); ++it) {
    if (it->substr(0, tileSize - 1) == startChunk.substr(1, tileSize - 1)) {
      endChunk = *it;
      break;
    }
  }
  if (endChunk == "") {
    return "";
  } else {
    word += endChunk[tileSize - 1];
  }
  delete[] validChunks;
  return word;
}
